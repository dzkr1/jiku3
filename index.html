<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Cube Position & Rotation Visualization</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: monospace;
      background: #111;
      color: #eee;
      display: flex;
      flex-direction: column;
      height: 100vh;
    }

    #threeContainer {
      flex: 1 1 auto;
      position: relative;
    }

    canvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    #graphs {
      display: flex;
      flex-direction: column;
      flex: 0 0 300px; /* 150px for each graph */
      background: #000;
      border-top: 1px solid #333;
      z-index: 10;
    }

    .graph {
      flex: 1;
      background: rgba(0, 0, 0, 0.85);
      border-top: 1px solid #222;
    }

    svg {
      width: 100%;
      height: 100%;
    }

    .axis path,
    .axis line {
      stroke: #aaa;
    }

    .axis text {
      fill: #aaa;
      font-size: 12px;
    }
  </style>
</head>
<body>
  <div id="threeContainer"></div>
  <div id="graphs">
    <div id="positionGraph" class="graph"></div>
    <div id="rotationGraph" class="graph"></div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.1/build/three.module.js';

    const container = document.getElementById('threeContainer');

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x111111);

    const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
    camera.position.set(5, 5, 10);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    container.appendChild(renderer.domElement);

    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(10, 10, 10);
    scene.add(light);
    scene.add(new THREE.AmbientLight(0x404040));

    const cubes = [];
    const originalPositions = [];
    const size = 1;
    const spacing = 2;
    const count = 5;

    const cubeGeometry = new THREE.BoxGeometry(size, size, size);
    const sphereGeometry = new THREE.SphereGeometry(size * 0.7, 16, 16);

    for (let x = 0; x < count; x++) {
      for (let y = 0; y < count; y++) {
        for (let z = 0; z < count; z++) {
          const color = new THREE.Color(Math.random(), Math.random(), Math.random());
          const material = new THREE.MeshStandardMaterial({ color });
          const mesh = new THREE.Mesh(cubeGeometry, material);
          const pos = new THREE.Vector3(
            (x - count / 2) * spacing,
            (y - count / 2) * spacing,
            (z - count / 2) * spacing
          );
          mesh.position.copy(pos);
          originalPositions.push(pos.clone());
          scene.add(mesh);
          cubes.push(mesh);
        }
      }
    }

    const mouse = { x: 0, y: 0 };
    window.addEventListener('mousemove', (e) => {
      const rect = container.getBoundingClientRect();
      mouse.x = ((e.clientX - rect.left) / rect.width - 0.5) * Math.PI;
      mouse.y = ((e.clientY - rect.top) / rect.height - 0.5) * Math.PI;
    });

    let scattered = false;
    window.addEventListener('click', () => {
      scattered = !scattered;
      cubes.forEach((mesh, i) => {
        if (scattered) {
          mesh.geometry = sphereGeometry;
          const offset = new THREE.Vector3(
            (Math.random() - 0.5) * 10,
            (Math.random() - 0.5) * 10,
            (Math.random() - 0.5) * 10
          );
          mesh.userData.targetPosition = originalPositions[i].clone().add(offset);
        } else {
          mesh.geometry = cubeGeometry;
          mesh.userData.targetPosition = originalPositions[i].clone();
        }
      });
    });

    // Graph setup
    function setupGraph(containerId, xLabel, yLabel, yDomain) {
      const container = d3.select(containerId);
      const width = container.node().clientWidth;
      const height = container.node().clientHeight;
      const margin = { top: 20, right: 20, bottom: 40, left: 50 };
      const innerWidth = width - margin.left - margin.right;
      const innerHeight = height - margin.top - margin.bottom;

      const svg = container.append('svg')
        .attr('width', width)
        .attr('height', height);

      const g = svg.append('g')
        .attr('transform', `translate(${margin.left},${margin.top})`);

      const xExtent = [-count * spacing / 2 - 5, count * spacing / 2 + 5];
      const xScale = d3.scaleLinear().domain(xExtent).range([0, innerWidth]);
      const yScale = d3.scaleLinear().domain(yDomain).range([innerHeight, 0]);

      g.append('g')
        .attr('transform', `translate(0,${innerHeight})`)
        .attr('class', 'axis')
        .call(d3.axisBottom(xScale))
        .append('text')
        .attr('x', innerWidth / 2)
        .attr('y', 35)
        .attr('fill', '#aaa')
        .attr('text-anchor', 'middle')
        .text(xLabel);

      g.append('g')
        .attr('class', 'axis')
        .call(d3.axisLeft(yScale))
        .append('text')
        .attr('transform', 'rotate(-90)')
        .attr('x', -innerHeight / 2)
        .attr('y', -40)
        .attr('fill', '#aaa')
        .attr('text-anchor', 'middle')
        .text(yLabel);

      const pointsGroup = g.append('g');

      return { xScale, yScale, pointsGroup };
    }

    const posGraph = setupGraph('#positionGraph', 'X Position', 'Z Position', [-count*spacing, count*spacing]);
    const rotGraph = setupGraph('#rotationGraph', 'X Position', 'Rotation Y', [-Math.PI, Math.PI]);

    function animate() {
      requestAnimationFrame(animate);

      cubes.forEach((mesh) => {
        mesh.rotation.x = mouse.y;
        mesh.rotation.y = mouse.x;

        if (mesh.userData.targetPosition) {
          mesh.position.lerp(mesh.userData.targetPosition, 0.05);
        }
      });

      const posData = cubes.map(mesh => ({
        x: mesh.position.x,
        z: mesh.position.z,
        color: mesh.material.color.getStyle()
      }));

      const rotData = cubes.map(mesh => ({
        x: mesh.position.x,
        ry: mesh.rotation.y,
        color: mesh.material.color.getStyle()
      }));

      // Position graph
      const posCircles = posGraph.pointsGroup.selectAll('circle').data(posData);
      posCircles.enter()
        .append('circle')
        .attr('r', 5)
        .attr('stroke', '#000')
        .attr('stroke-width', 1)
        .merge(posCircles)
        .attr('cx', d => posGraph.xScale(d.x))
        .attr('cy', d => posGraph.yScale(d.z))
        .attr('fill', d => d.color);
      posCircles.exit().remove();

      // Rotation graph
      const rotCircles = rotGraph.pointsGroup.selectAll('circle').data(rotData);
      rotCircles.enter()
        .append('circle')
        .attr('r', 5)
        .attr('stroke', '#000')
        .attr('stroke-width', 1)
        .merge(rotCircles)
        .attr('cx', d => rotGraph.xScale(d.x))
        .attr('cy', d => rotGraph.yScale(d.ry))
        .attr('fill', d => d.color);
      rotCircles.exit().remove();

      renderer.render(scene, camera);
    }

    animate();

    window.addEventListener('resize', () => {
      const w = container.clientWidth;
      const h = container.clientHeight;
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      renderer.setSize(w, h);
    });
  </script>
</body>
</html>
